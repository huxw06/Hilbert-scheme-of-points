  glove List :=L->(                    --Given a 3-dimensional partition L, this functions gives the glove of L.
      G:={};
      for i from 0 to #L-1 do (
      		if member(L#i+{1,0,0},L)==false then
            	G=append(G, L#i+{1,0,0});
            if member(L#i+{0,1,0},L)==false then	
            	G=append(G, L#i+{0,1,0});
            if member(L#i+{0,0,1},L)==false then	
            	G=append(G, L#i+{0,0,1});
            );
      unique G
  )     


minLattice List:=L->(                --Given a finite set L of lattices in $\mathbb{Z}^3$, this function gives the set of minimal lattices of L.
	l:=#L;
	for i from 0 to l-1 do (
		for j from 0 to #L-1 do (
			if L#(l-1-i)#0-L#j#0>=0 and L#(l-1-i)#1-L#j#1>=0 and L#(l-1-i)#2-L#j#2>=0 
			and L#(l-1-i)#0-L#j#0+L#(l-1-i)#1-L#j#1+L#(l-1-i)#2-L#j#2>0 then break
			L=drop(L,{(l-1-i),(l-1-i)});
		);
	);	
	L
)    




 adjPairs List :=L->(              --Given a finite set of lattices, this function gives the set of adjoint pairs of lattices in L.
    A:={};
    for i from 0 to #L-1 do
        (for j from 0 to #L-1 do(
            if L#i-L#j=={1,0,0} or L#i-L#j=={0,1,0} or L#i-L#j=={0,0,1}
           		or L#i-L#j=={1,-1,0} or L#i-L#j=={1,0,-1} or L#i-L#j=={0,1,-1}
            then
            A=append(A,{L#i,L#j});
         	);
        );
    A
)



cScripts List :=L->(              --Given a 3D partition L, cScripts list the pairs of  (subscripts, superscritps) of the variables in Huibregtse's 
                                  description of Haiman equations; but note that we keep the redundant ones whose the superscripts lie in L.
	A:= {};
	M:=L|glove(L);
	for i from 0 to #L-1 do
		for j from 0 to #M-1 do
		A=append(A, {L#i,M#j});
	A	
)






cMonomials List:=L->(        
	A:={};
	for i from 0 to #L-1 do
		A=append(A,c_(L#i));
	A	
)




eqHaiman List :=L->(            --Given a 3D partition L, eqHaiman(L) is the list of Haiman equations in Huibregtse's decription
	M:=glove L;
	A:={};
	N:=adjPairs M;
	for i from 0 to #N-1 do
		for j from 0 to #L-1 do
			if N#i#0-N#i#1=={1,0,0} then
				A=append(A,c_({L#j,N#i#0})-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{1,0,0}})))
			else if N#i#0-N#i#1=={0,1,0} then
				A=append(A,c_({L#j,N#i#0})-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{0,1,0}})))
			else if N#i#0-N#i#1=={0,0,1} then
				A=append(A,c_({L#j,N#i#0})-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{0,0,1}})))	
			else if N#i#0-N#i#1=={1,-1,0} then
				A=append(A,(sum for k from 0 to #L-1 list c_({L#k,N#i#0})*c_({L#j,L#k+{0,1,0}}))-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{1,0,0}})))
			else if N#i#0-N#i#1=={1,0,-1} then
				A=append(A,(sum for k from 0 to #L-1 list c_({L#k,N#i#0})*c_({L#j,L#k+{0,0,1}}))-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{1,0,0}})))
			else if N#i#0-N#i#1=={0,1,-1} then
				A=append(A,(sum for k from 0 to #L-1 list c_({L#k,N#i#0})*c_({L#j,L#k+{0,0,1}}))-(sum for k from 0 to #L-1 list c_({L#k,N#i#1})*c_({L#j,L#k+{0,1,0}})));
	H:=ideal A;
	for i from 0 to #L-1 do
	for j from 0 to #L-1 do
		if i==j then 
				H=sub(H,{c_({L#i,L#j})=>1})
		else if i!=j then
				H=sub(H,{c_({L#i,L#j})=>0});
	H_*					
)






simpleElimination List:=L->(     --this function do the simple elimination of variables described in algorithm 4.21 in my paper. Given a list of variables A
                                   and a list L of equations of variables in A, the output is the remaining variables A, the ideal I generated by the 
                                   resulted equations, and the eliminated variables B.
	I:=ideal(L#1);
	l:=#(L#0);
	A:=L#0;
	B:={};
	for i from 0 to l-1 do
		for j from 0 to #(I_*)-1 do
			if diff(L#0#(l-1-i),(I_*)#j)!=0 
		and isConstant diff(L#0#(l-1-i),(I_*)#j)
				 then (
				I=sub(I,{L#0#(l-1-i)=>L#0#(l-1-i)-(I_*)#j/coefficient(L#0#(l-1-i),(I_*)#j)});
			    B=append(B,A#(l-1-i)); 
				A=drop(A,{(l-1-i),(l-1-i)});
				);
	{A,I,B}			
)









simpleEliminationExpressionOfAllVariables List:=L->(     --this is a function enhancing the simpleElimination: it has an output C,
                                                         --which expresses the eliminated variables in terms of  the remaining variables. 
	I:=ideal(L#1);
	l:=#(L#0);
	A:=L#0;
	C:=L#0;
	MC:=transpose matrix vector C;
	J:={};
	for i from 0 to l-1 do
		for j from 0 to #(I_*)-1 do
			if diff(L#0#(l-1-i),(I_*)#j)!=0 
		and isConstant diff(L#0#(l-1-i),(I_*)#j)
				 then (
					MC=sub(MC,{L#0#(l-1-i)=>L#0#(l-1-i)-(I_*)#j/coefficient(L#0#(l-1-i),(I_*)#j)});
					I=sub(I,{L#0#(l-1-i)=>L#0#(l-1-i)-(I_*)#j/coefficient(L#0#(l-1-i),(I_*)#j)});
					A=drop(A,{(l-1-i),(l-1-i)});
					J=append(J,l-1-i);
				);
	C=flatten entries MC;
	D={};
	for i from 0 to #J-1 do
		D=append(D,L#0#(J#(#J-1-i))=>C#(J#(#J-1-i)));		
	{A,I,D}			
)





simpleEliminationDegTwoPart List:=L->(                --this is a variant of simpleElimination; in each step the resulting equations modulo the terms of degree >=3
	I:=ideal(L#1);
	l:=#(L#0);
	A:=L#0;
	B:={};
	for i from 0 to l-1 do
		for j from 0 to #(I_*)-1 do
			if diff(L#0#(l-1-i),(I_*)#j)!=0 
		and isConstant diff(L#0#(l-1-i),(I_*)#j)
				 then (
				I=sub(I,{L#0#(l-1-i)=>L#0#(l-1-i)-(I_*)#j/coefficient(L#0#(l-1-i),(I_*)#j)});
				M={};
				N=I_*;
				for i from 0 to #N-1 do (
					M=append(M,part(1,2,N#i))
					);
				I=ideal M;	
			    B=append(B,A#(l-1-i)); 
				A=drop(A,{(l-1-i),(l-1-i)});
				);
	{A,I,B}			
)



nonZeroConstantTerm List:=L->(
	f:=L#0;
	for i from 0 to #(L#1)-1 do
		f=sub(f,{L#1#i=>0});
	f !=0	
)



rationalElimination List:=L->(                   --this function is used to allow the fractions in simple eliminations of variables; it is not used in the paper
	l:=#(L#0);
	A:=L#0;
	B:=L#1;
	R:=L#2;
	P:=gens R;
	Q:={};
	for i from 0 to l-1 do
		for j from 0 to #B-1 do (
			if  nonZeroConstantTerm {diff(A#(l-1-i),B#j),P}
			and degree (A#(l-1-i),B#j)==1
			then break (
				use frac R;
				MB:=matrix vector B;
				MB=sub(MB,{A#(l-1-i)=>A#(l-1-i)-B#j/diff(A#(l-1-i),B#j)});
				EB:=flatten entries MB;
				NB:={};
				DB:={};
				for k from 0 to #EB-1 do (
					NB=append(NB,numerator(EB#k));
					DB=append(DB,denominator(EB#k));
				);
				NQ:={};
				if Q!={} then (
				MQ:=matrix vector Q;
				MQ=sub(MQ,{A#(l-1-i)=>A#(l-1-i)-B#j/diff(A#(l-1-i),B#j)});
				EQ:=flatten entries MQ;
				for k from 0 to #EQ-1 do (
					NQ=append(NQ,numerator(EQ#k));
				);
				);
				B=NB;
				Q=unique (NQ|DB);
				A=drop(A,{(l-1-i),(l-1-i)});
				use R
				);
		);		
	{A,B,Q}			
)





changeVarHaiman List:=L->(          --This is the function realizing algorithm 4.21 in my paper.
    V:=cMonomials cScripts L;
    R:=QQ[V];
    E:=gens R;
    A:=set E;
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	A=A-set{c_({L#i,L#j})};
    N:=minLattice glove L;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        A=A-set{c_({L#i,N#j})};
    U:=toList A;
    H:=eqHaiman L;
    rH0:=simpleElimination {U,H};
    B:=rH0#0;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        B=append(B,c_({L#i,N#j}));
    rH:=simpleElimination {B,rH0#1_*};
    S:=QQ[x_1..x_(#(rH#0))];
    W:={};
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	W=append(W,c_({L#i,L#j}));
    for i from 0 to #(rH0#2)-1 do 
        W=append(W,rH0#2#i); 
    for i from 0 to #(rH#2)-1 do 
        W=append(W,rH#2#i);     	 	
    F:={};
    for i from 0 to #W-1 do 
        F=append(F,(W#i)=>0); 
    for i from 0 to #(rH#0)-1 do 
        F=append(F,(rH#0#i)=>x_(i+1));
    f:=map(S,R,F);
    M:={};
    for i from 0 to #(rH#1_*)-1 do 
    	M=append(M,f(rH#1_i));
    SUB={};
    for i from 0 to #(rH#0)-1 do (
        SUB=append(SUB,rH#0#i=>x_(i+1));
        );	
    {SUB,M}
)



changeVarHaimanDeleteDegLargerThanTwo List:=L->(         --This is a variant of  algorithm 4.21: once we know that the final ideal should be generated by equations of 
                                                         --minimal degree two, we use this function to find them more quickly, throwing out equations of minimal 
                                                         --degree \geq 3 in every step. Of course we need to verify that the final ideal is generated by them, by a
                                                         --indirect argument.
    V:=cMonomials cScripts L;
    R:=QQ[V];
    E:=gens R;
    A:=set E;
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	A=A-set{c_({L#i,L#j})};
    N:=minLattice glove L;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        A=A-set{c_({L#i,N#j})};
    U:=toList A;
    H:=eqHaiman L;
    rH0:=simpleEliminationDeleteDegLargerThanTwo {U,H};
    B:=rH0#0;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        B=append(B,c_({L#i,N#j}));
    rH:=simpleEliminationDeleteDegLargerThanTwo {B,rH0#1_*};
    S:=QQ[x_1..x_(#(rH#0))];
    W:={};
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	W=append(W,c_({L#i,L#j}));
    for i from 0 to #(rH0#2)-1 do 
        W=append(W,rH0#2#i); 
    for i from 0 to #(rH#2)-1 do 
        W=append(W,rH#2#i);     	 	
    F:={};
    for i from 0 to #W-1 do 
        F=append(F,(W#i)=>0); 
    for i from 0 to #(rH#0)-1 do 
        F=append(F,(rH#0#i)=>x_(i+1));
    f:=map(S,R,F);
    M:={};
    for i from 0 to #(rH#1_*)-1 do 
    	M=append(M,f(rH#1_i));
    SUB={};
    for i from 0 to #(rH#0)-1 do (
        SUB=append(SUB,rH#0#i=>x_(i+1));
        );	
    {SUB,M}
)



changeVarHaimanTotal List:=L->(         --this is a variant of changeVarHaiman; it contains an additional output that express all eliminated variables 
                                        --in terms of the remaining variables; This function is not explicitly used in my paper. 
                                        --But it helps to understand the local structure 
                                        --of $\mathrm{Hilb}^7(\mathbb{A}^3)$ at the  singularities of extra dimension 8.
    V:=cMonomials cScripts L;
    R:=QQ[V];
    E:=gens R;
    A:=set E;
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	A=A-set{c_({L#i,L#j})};
    D=toList A; 	
    N:=minLattice glove L;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        A=A-set{c_({L#i,N#j})};
    U:=toList A;
    H:=eqHaiman L;
    rH0:=simpleEliminationRememberOriginalVariables {U,H,D};
    B:=rH0#0;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        B=append(B,c_({L#i,N#j}));
    rH:=simpleEliminationRememberOriginalVariables {B,rH0#1_*,rH0#3};
    S:=QQ[x_1..x_(#(rH#0))];
    W:={};
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	W=append(W,c_({L#i,L#j}));
    for i from 0 to #(rH0#2)-1 do 
        W=append(W,rH0#2#i); 
    for i from 0 to #(rH#2)-1 do 
        W=append(W,rH#2#i);     	 	
    F:={};
    for i from 0 to #W-1 do 
        F=append(F,(W#i)=>0); 
    for i from 0 to #(rH#0)-1 do 
        F=append(F,(rH#0#i)=>x_(i+1));
    f:=map(S,R,F);
    M:={};
    for i from 0 to #(rH#1_*)-1 do 
    	M=append(M,f(rH#1_i));
    TotM:={};
    for i from 0 to #D-1 do 
    	TotM=append(TotM,f(rH#3_i));	
    SUB={};
    for i from 0 to #(rH#0)-1 do (
        SUB=append(SUB,rH#0#i=>x_(i+1));	   
        );
    TotSUB={};
    for i from 0 to #D-1 do (
    	TotSUB=append(TotSUB, D#i=>TotM#i);
    );    	
    {SUB,M,TotSUB}
)



changeVarHaimanDegTwoPart List:=L->(      --this is a variant of changeVarHaiman; in each step the resulting equations modulo the terms of degree >=3
    V:=cMonomials cScripts L;
    R:=QQ[V];
    E:=gens R;
    A:=set E;
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	A=A-set{c_({L#i,L#j})};
    N:=minLattice glove L;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        A=A-set{c_({L#i,N#j})};
    U:=toList A;
    H:=eqHaiman L;
    rH0:=simpleEliminationDegTwoPart {U,H};
    B:=rH0#0;
    for i from 0 to #L-1 do
    for j from 0 to #N-1 do
        B=append(B,c_({L#i,N#j}));
    rH:=simpleEliminationDegTwoPart {B,rH0#1_*};
    S:=QQ[x_1..x_(#(rH#0))];
    W:={};
    for i from 0 to #L-1 do
    for j from 0 to #L-1 do
     	W=append(W,c_({L#i,L#j}));
    for i from 0 to #(rH0#2)-1 do 
        W=append(W,rH0#2#i); 
    for i from 0 to #(rH#2)-1 do 
        W=append(W,rH#2#i);     	 	
    F:={};
    for i from 0 to #W-1 do 
        F=append(F,(W#i)=>0); 
    for i from 0 to #(rH#0)-1 do 
        F=append(F,(rH#0#i)=>x_(i+1));
    f:=map(S,R,F);
    M:={};
    for i from 0 to #(rH#1_*)-1 do 
    	M=append(M,f(rH#1_i));
    SUB={};
    for i from 0 to #(rH#0)-1 do (
        SUB=append(SUB,rH#0#i=>x_(i+1));
        );	
    M1={};
    for i from 0 to #M-1 do
    	M1=append(M1,part(1,2,M#i));
    X:=gens S;
    rHmod=simpleEliminationDegTwoPart {X,M1};
    D:=rHmod#1_*;
    M2={};
    for i from 0 to #D-1 do
    	M2=append(M2,part(1,2,D#i));
    M2=unique M2;
    {SUB,M2}	
)









collectQuadrics List:=L->(   
	Q:={};
	for i from 0 to #L-1 do (
		if L#i !=0 and 
		degree L#i=={2} then
			Q=append(Q,L#i);
	);		
	Q	
)


minDegree = F->(
	M:=matrix F;
	L:=flatten entries monomials M;
	D:=degree L#0;
	for i from 1 to #L-1 do (
		if degree L#i<D then 
			D=degree L#i;
	);
	D
)

minDegOneElements List:=L->(
      S:={};
      for i from 0 to #L-1 do
      	if  L#i !=0   
		and minDegree L#i=={1} then
      		S=append(S,L#i);
      S
)


minDegTwoElements List:=L->(
	S:={};
	for i from 0 to #L-1 do
		if L#i !=0   
		and minDegree L#i=={2} then
			S=append(S,L#i);
	S
)


